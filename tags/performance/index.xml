<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>performance on 647 Universe</title>
    <link>https://bwangel.me/tags/performance/</link>
    <description>Recent content in performance on 647 Universe</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>cn</language>
    <lastBuildDate>Sun, 13 Aug 2023 16:17:52 +0800</lastBuildDate><atom:link href="https://bwangel.me/tags/performance/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>QPS 和 RT 的关系</title>
      <link>https://bwangel.me/docs/performance/qps_rt/</link>
      <pubDate>Sun, 13 Aug 2023 16:17:52 +0800</pubDate>
      
      <guid>https://bwangel.me/docs/performance/qps_rt/</guid>
      <description>术语说明 QPS: Query Per Second RT: Response Time RT_CPU: 单个请求中的 CPU 时间 RT_WAIT: 单个请求中除了 CPU 时间外的其他时间(等待时间) 结论 单线程情况下, QPS = 1000 / RT
多线程情况下，最好的情况(最佳线程数)是
QPS = 1000 / RT_CPU
最佳线程数 = (RT_CPU+RT_WAIT) / RT_CPU * CPU核心
线程数超过 最佳线程数 后, 系统的 QPS 不会再增加了，如果进一步增多，因为多个线程抢夺 CPU 资源导致的时间浪费，QPS 还会下降。 说明 一个请求我们除了有 CPU 执行时间外，还有等待时间(等待IO/等待锁资源)。
如果单个请求的等待时间占比很高，我们可以增加线程数，提升 CPU 的利用率，这样 QPS 也会随之增加。(CPU 利用率达到 85% 以上才比较正常) 线程本身也会消耗资源，它消耗的是 OS 级别的内存，不是进程内存，如果线程数小于 1000, 那么对于系统性能的影响可以忽略不计。 如果单个请求的 CPU 时间占比很高，此时 CPU 成为系统瓶颈，那么系统整体的 QPS 已经没有提升空间了，要么优化程序，减少 CPU 指令数，要么增加 CPU 资源。 我们提升系统 QPS 的目的就是提升 CPU 的利用率，使 CPU 成为系统瓶颈。 </description>
    </item>
    
  </channel>
</rss>
