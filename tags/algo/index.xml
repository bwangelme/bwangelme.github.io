<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Algo on 647 Universe</title>
    <link>https://bwangel.me/tags/algo/</link>
    <description>Recent content in Algo on 647 Universe</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>cn</language>
    <lastBuildDate>Thu, 02 May 2024 11:39:20 +0800</lastBuildDate><atom:link href="https://bwangel.me/tags/algo/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>排序</title>
      <link>https://bwangel.me/docs/algo/sort/</link>
      <pubDate>Thu, 02 May 2024 11:39:20 +0800</pubDate>
      
      <guid>https://bwangel.me/docs/algo/sort/</guid>
      <description>归并排序 思路 mergeSortC 对数组的子数组进行排序，当 len(子数组) == 1 的时候，这个数组就是有序的，此时就是递归出口 merge 对有序的子数组进行合并。 0. left, right 两个子数组内部的元素是有序的 就像交换需要创建 tmp 变量。merge 时 先创建 tmp 数组 将 left, right 两个子数组的元素 有序 放入 tmp 中 将子数组中剩余的部分放入到 tmp 中 将 tmp 更新到 arr 的对应位置 特性 无论数据源是什么，归并排序的时间复杂度固定是 O(nlogn) 归并排序的空间复杂度是 O(1) ，因为每次只有一个函数会申请一个临时数组 归并排序是稳定性排序，两个相同的元素，排序之后它们的顺序不会变 代码 func MergeSort(arr []int64) []int64 { mergeSortC(arr, 0, len(arr)-1) return arr } func mergeSortC(arr []int64, start, end int) { if start &amp;gt;= end { return } q := (start + end) / 2 mergeSortC(arr, start, q) mergeSortC(arr, q+1, end) merge(arr, start, q, q+1, end) } func merge(arr []int64, leftStart, leftEnd int, rightStart, rightEnd int) { var tmp = make([]int64, 0) var leftIdx, rightIdx = leftStart, rightStart for leftIdx &amp;lt;= leftEnd &amp;amp;&amp;amp; rightIdx &amp;lt;= rightEnd { if arr[leftIdx] &amp;lt;= arr[rightIdx] { tmp = append(tmp, arr[leftIdx]) leftIdx++ } else { tmp = append(tmp, arr[rightIdx]) rightIdx++ } } // 将子数组剩余部分放入到 tmp 中 var ( remainStart = leftIdx remainEnd = leftEnd ) if leftIdx &amp;gt; leftEnd { remainStart = rightIdx remainEnd = rightEnd } for remainStart &amp;lt;= remainEnd { tmp = append(tmp, arr[remainStart]) remainStart++ } // 将 tmp 的元素放入 arr 对应位置中 for idx := 0; idx &amp;lt;= (rightEnd - leftStart); idx++ { arr[leftStart+idx] = tmp[idx] } } 时间复杂度 N 等于数组长度</description>
    </item>
    
    <item>
      <title>138: 随机链表的复制</title>
      <link>https://bwangel.me/docs/algo/leetcode/138/</link>
      <pubDate>Wed, 01 May 2024 23:14:42 +0800</pubDate>
      
      <guid>https://bwangel.me/docs/algo/leetcode/138/</guid>
      <description>题目 给你一个长度为 n 的链表，每个节点包含一个额外增加的随机指针 random ，该指针可以指向链表中的任何节点或空节点。
构造这个链表的深拷贝。深拷贝应该正好由 n 个全新节点组成，其中每个新节点的值都设为其对应的原节点的值。
新节点的 next 指针和 random 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。
复制链表中的指针都不应指向原链表中的节点 。
例如，如果原链表中有 X 和 Y 两个节点，其中 X.random &amp;ndash;&amp;gt; Y 。那么在复制链表中对应的两个节点 x 和 y ，同样有 x.random &amp;ndash;&amp;gt; y 。
返回复制链表的头节点。
用一个由 n 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 [val, random_index] 表示：
val：一个表示 Node.val 的整数 random_index：随机指针指向的节点索引（范围从 0 到 n-1）；如果不指向任何节点，则为 null 你的代码只接受原链表的头节点 head 作为传入参数。
提示：
0 &amp;lt;= n &amp;lt;= 1000 -10^4 &amp;lt;= Node.val &amp;lt;= 10^4 Node.random 为 null 或指向链表中的节点。 解题思路 假设存在链表 A -&amp;gt; B -&amp;gt; C</description>
    </item>
    
    <item>
      <title>75: 颜色分类</title>
      <link>https://bwangel.me/docs/algo/leetcode/leetcode-75/</link>
      <pubDate>Wed, 01 May 2024 16:14:46 +0800</pubDate>
      
      <guid>https://bwangel.me/docs/algo/leetcode/leetcode-75/</guid>
      <description>题目描述 给定一个包含红色、白色和蓝色、共 n 个元素的数组 nums ，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。
我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。
必须在不使用库内置的 sort 函数的情况下解决这个问题。
示例 1： 输入：nums = [2,0,2,1,1,0] 输出：[0,0,1,1,2,2] 示例 2： 输入：nums = [2,0,1] 输出：[0,1,2] 提示：
n == nums.length 1 &amp;lt;= n &amp;lt;= 300 nums[i] 为 0、1 或 2 进阶：
你能想出一个仅使用常数空间的一趟扫描算法吗？
解题思路 程序运行结束后，数组中分为三个区域，0 1 2 区域
使用两个指针 p_zero 和 p_two, 分别表示 0 区域的尾部后一位和 2 区域的头部前一位
遍历一遍数组，遇到数字 0 放到 0 区域尾部, 遇到数字2放到 2 区域头部，遍历完成后，数组中的数字也自动分好区了
注意:
2 区域中的数字不需要再移动了 ，因此我们遍历时，遍历到2区域的头部就跳出循环。 循环跳出的条件是 i &amp;lt;= p_two， 要遍历数组中每一个数字，因此要遍历到 p_two 代码 func sortColors(nums []int) { var ( p_zero = 0 i = 0 p_two = len(nums) - 1 ) // 注意，这里的条件是 i &amp;lt;= p_two, 必须要比较数组中的所有元素 for i &amp;lt;= p_two { if nums[i] == 0 { swap(nums, i, p_zero) p_zero++ // 当前数字被交换到后面了，当前数字一定是0,因此 i 可以往后移动一位 i++ } else if nums[i] == 1 { // 当前数字是1的时候，不交换 i++ } else { // 当前数字是2的时候，将当前数字交换到数组尾部 swap(nums, i, p_two) // 当前交换过来的数字是从数组后面交换过来的，不确定值，因此 i 不能 ++ p_two-- } } } func swap(nums []int, x, y int) { tmp := nums[x] nums[x] = nums[y] nums[y] = tmp } 复杂度分析 N == len(nums) 时间复杂度: O(N), 数组只遍历了一遍 空间复杂度: O(1), 没有额外申请其他的数据结构 </description>
    </item>
    
    <item>
      <title>Leetcode第96题</title>
      <link>https://bwangel.me/docs/algo/leetcode/leetcode-96/</link>
      <pubDate>Fri, 03 Nov 2023 08:45:11 +0800</pubDate>
      
      <guid>https://bwangel.me/docs/algo/leetcode/leetcode-96/</guid>
      <description>题目 给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。
示例 1：
输入：n = 3 输出：5
示例 2：
输入：n = 1 输出：1
提示：
1 &amp;lt;= n &amp;lt;= 19 解题思路 这个题目主要的难度在公式推导上，我们可以用动态规划的思路来求解。
令 \( G(N) \) 表示 n 互不相同的整数组成的二叉搜索树的数量。 \( F(i, N) \) 表示由 i 作为根节点，N 个互补相同的整数组成的二叉搜索树的数量 可得, \( G(N) \) 是由每个 i 作为根节点的互不相同的二叉搜索树的数量的总和，此公式记做公式(1) $$G(N) = \sum_{i=1}^{N} F(i, N) \tag{1}$$接着，我们需要再推导出 \( F(i, N) \) 和 \( G(N) \) 的关系，就可以得到我们的递推公式了。
要想求 i 作为根节点，N 个互补相同的整数组成的二叉搜索树的数量，我们可以先求出左右两个子树的数量，左右两个子树相乘，即是总的数量。</description>
    </item>
    
    <item>
      <title>二分查找</title>
      <link>https://bwangel.me/docs/algo/binary_search/</link>
      <pubDate>Tue, 10 Oct 2023 09:31:53 +0800</pubDate>
      
      <guid>https://bwangel.me/docs/algo/binary_search/</guid>
      <description>二分查找的注意点 循环的条件: left &amp;lt;= right mid 计算方法: # 用移位预算速度更快 mid = left + ((right-left) &amp;gt;&amp;gt; 1)) left 和 right 的更新方法 left = mid + 1 right = mid - 1 // BinarySearchLastV2 /** ## 功能 返回 arr 中最后一个 == num 的数字的索引 **/ func BinarySearchLastV2(arr []int64, num int64) int { var ( low = 0 n = len(arr) high = n - 1 ) /** 1. for 循环结束后, low &amp;gt; high 2.</description>
    </item>
    
    <item>
      <title>Leetcode 142: 环形链表 II</title>
      <link>https://bwangel.me/docs/algo/leetcode/leetcode-142/</link>
      <pubDate>Sun, 11 Sep 2022 10:54:04 +0800</pubDate>
      
      <guid>https://bwangel.me/docs/algo/leetcode/leetcode-142/</guid>
      <description></description>
    </item>
    
    <item>
      <title>算法中使用哨兵变量(TODO)</title>
      <link>https://bwangel.me/docs/algo/algo-sentry/</link>
      <pubDate>Sun, 11 Sep 2022 10:52:23 +0800</pubDate>
      
      <guid>https://bwangel.me/docs/algo/algo-sentry/</guid>
      <description>背景 哨兵，现实中是用于解决国家之间的边界问题。
在算法程序中，我们设置一些冗余的变量，让算法程序处理边界问题时更加容易，这些变量就被称为哨兵。
本文将会举例说明，哨兵变量在算法程序中的应用。
插入排序 插入排序是一种常用的排序算法，它的思路是
用 i 从 1 开始遍历数组中每个元素 从后往前遍历 1-i 的每个元素，找到第一个比当前元素小的元素，将其插入到该元素之后 Note: 先挪位置，循环结束后再在 j 指示的索引中(第一个比当前元素小的元素)插入当前值 func InsertSort[T ttypes.Number](arr []T) []T { res := make([]T, len(arr)) copy(res, arr) for i := 1; i &amp;lt; len(res); i++ { j := i current := res[i] for j &amp;gt; 0 &amp;amp;&amp;amp; res[j-1] &amp;gt; current { res[j] = res[j-1] j-- } res[j] = current } return res } 演示图:
哨兵模式 哨兵模式的代码如下，它在数组的前面添加一个元素。
每次开始遍历前，它将当前需要插入的元素放到数组头部(res[0])。这样就算 1-i 中没有比 res[i] 小的元素，但循环到最后还是会触发条件 not (res[0] &amp;gt; current), 达到跳出循环的目的。</description>
    </item>
    
    <item>
      <title>Go与数据结构之二叉搜索树</title>
      <link>https://bwangel.me/docs/algo/go-binarysearchtree/</link>
      <pubDate>Thu, 01 Mar 2018 22:22:52 +0800</pubDate>
      
      <guid>https://bwangel.me/docs/algo/go-binarysearchtree/</guid>
      <description>&lt;p&gt;&lt;strong&gt;简介&lt;/strong&gt;: 利用Go语言实现二叉搜索树并为其编写单元测试&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
