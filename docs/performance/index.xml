<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>性能分析 on 647 Universe</title>
    <link>https://bwangel.me/docs/performance/</link>
    <description>Recent content in 性能分析 on 647 Universe</description>
    <generator>Hugo</generator>
    <language>cn</language>
    <lastBuildDate>Tue, 19 Dec 2023 18:56:31 +0800</lastBuildDate>
    <atom:link href="https://bwangel.me/docs/performance/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>QPS 和 RT 的关系</title>
      <link>https://bwangel.me/docs/performance/qps_rt/</link>
      <pubDate>Sun, 13 Aug 2023 16:17:52 +0800</pubDate>
      <guid>https://bwangel.me/docs/performance/qps_rt/</guid>
      <description>术语说明 QPS: Query Per Second RT: Response Time RT_CPU: 单个请求中的 CPU 时间 RT_WAIT: 单个请求中除了 CPU 时间外的其他时间(等待时间) 结论 单线程情况下, QPS = 1000 / RT&#xA;多线程情况下，最好的情况(最佳线程数)是&#xA;QPS = 1000 / RT_CPU&#xA;最佳线程数 = (RT_CPU+RT_WAIT) / RT_CPU * CPU核心&#xA;线程数超过 最佳线程数 后, 系统的 QPS 不会再增加了，如果进一步增多，因为多个线程抢夺 CPU 资源导致的时间浪费，QPS 还会下降。 说明 一个请求我们除了有 CPU 执行时间外，还有等待时间(等待IO/等待锁资源)。&#xA;如果单个请求的等待时间占比很高，我们可以增加线程数，提升 CPU 的利用率，这样 QPS 也会随之增加。(CPU 利用率达到 85% 以上才比较正常) 线程本身也会消耗资源，它消耗的是 OS 级别的内存，不是进程内存，如果线程数小于 1000, 那么对于系统性能的影响可以忽略不计。 如果单个请求的 CPU 时间占比很高，此时 CPU 成为系统瓶颈，那么系统整体的 QPS 已经没有提升空间了，要么优化程序，减少 CPU 指令数，要么增加 CPU 资源。 我们提升系统 QPS 的目的就是提升 CPU 的利用率，使 CPU 成为系统瓶颈。 </description>
    </item>
    <item>
      <title>Latency</title>
      <link>https://bwangel.me/docs/performance/latency/</link>
      <pubDate>Tue, 19 Dec 2023 18:51:09 +0800</pubDate>
      <guid>https://bwangel.me/docs/performance/latency/</guid>
      <description>Latency Comparison Numbers (~2012) Operation ns µs ms note L1 cache reference 0.5 ns Branch mispredict 5 ns L2 cache reference 7 ns 14x L1 cache Mutex lock/unlock 25 ns Main memory reference 100 ns 20x L2 cache, 200x L1 cache Compress 1K bytes with Zippy 3,000 ns 3 µs Send 1K bytes over 1 Gbps network 10,000 ns 10 µs Read 4K randomly from SSD* 150,000 ns 150 µs ~1GB/sec SSD Read 1 MB sequentially from memory 250,000 ns 250 µs Round trip within same datacenter 500,000 ns 500 µs Read 1 MB sequentially from SSD* 1,000,000 ns 1,000 µs 1 ms ~1GB/sec SSD, 4X memory Disk seek 10,000,000 ns 10,000 µs 10 ms 20x datacenter roundtrip Read 1 MB sequentially from disk 20,000,000 ns 20,000 µs 20 ms 80x memory, 20X SSD Send packet CA -&amp;gt; Netherlands -&amp;gt; CA 150,000,000 ns 150,000 µs 150 ms Notes 1 ns = 10^-9 seconds 1 us = 10^-6 seconds = 1,000 ns 1 ms = 10^-3 seconds = 1,000 us = 1,000,000 ns Credit By Jeff Dean: http://research.</description>
    </item>
  </channel>
</rss>
