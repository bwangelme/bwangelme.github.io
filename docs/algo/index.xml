<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>算法 on 647 Universe</title>
    <link>https://bwangel.me/docs/algo/</link>
    <description>Recent content in 算法 on 647 Universe</description>
    <generator>Hugo</generator>
    <language>cn</language>
    <lastBuildDate>Tue, 22 Oct 2024 13:24:41 +0800</lastBuildDate>
    <atom:link href="https://bwangel.me/docs/algo/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>排序</title>
      <link>https://bwangel.me/docs/algo/sort/</link>
      <pubDate>Thu, 02 May 2024 11:39:20 +0800</pubDate>
      <guid>https://bwangel.me/docs/algo/sort/</guid>
      <description>归并排序 思路 mergeSortC 对数组的子数组进行排序，当 len(子数组) == 1 的时候，这个数组就是有序的，此时就是递归出口 merge 对有序的子数组进行合并。 0. left, right 两个子数组内部的元素是有序的 就像交换需要创建 tmp 变量。merge 时 先创建 tmp 数组 将 left, right 两个子数组的元素 有序 放入 tmp 中 将子数组中剩余的部分放入到 tmp 中 将 tmp 更新到 arr 的对应位置 特性 无论数据源是什么，归并排序的时间复杂度固定是 O(nlogn) 归并排序的空间复杂度是 O(1) ，因为每次只有一个函数会申请一个临时数组 归并排序是稳定性排序，两个相同的元素，排序之后它们的顺序不会变 代码 func MergeSort(arr []int64) []int64 { mergeSortC(arr, 0, len(arr)-1) return arr } func mergeSortC(arr []int64, start, end int) { if start &amp;gt;= end { return } q := (start + end) / 2 mergeSortC(arr, start, q) mergeSortC(arr, q+1, end) merge(arr, start, q, q+1, end) } func merge(arr []int64, leftStart, leftEnd int, rightStart, rightEnd int) { var tmp = make([]int64, 0) var leftIdx, rightIdx = leftStart, rightStart for leftIdx &amp;lt;= leftEnd &amp;amp;&amp;amp; rightIdx &amp;lt;= rightEnd { if arr[leftIdx] &amp;lt;= arr[rightIdx] { tmp = append(tmp, arr[leftIdx]) leftIdx++ } else { tmp = append(tmp, arr[rightIdx]) rightIdx++ } } // 将子数组剩余部分放入到 tmp 中 var ( remainStart = leftIdx remainEnd = leftEnd ) if leftIdx &amp;gt; leftEnd { remainStart = rightIdx remainEnd = rightEnd } for remainStart &amp;lt;= remainEnd { tmp = append(tmp, arr[remainStart]) remainStart++ } // 将 tmp 的元素放入 arr 对应位置中 for idx := 0; idx &amp;lt;= (rightEnd - leftStart); idx++ { arr[leftStart+idx] = tmp[idx] } } 时间复杂度 N 等于数组长度</description>
    </item>
    <item>
      <title>二分查找</title>
      <link>https://bwangel.me/docs/algo/binary_search/</link>
      <pubDate>Tue, 10 Oct 2023 09:31:53 +0800</pubDate>
      <guid>https://bwangel.me/docs/algo/binary_search/</guid>
      <description>二分查找的注意点 循环的条件: left &amp;lt;= right mid 计算方法: # 用移位预算速度更快 mid = left + ((right-left) &amp;gt;&amp;gt; 1)) left 和 right 的更新方法 left = mid + 1 right = mid - 1 // BinarySearchLastV2 /** ## 功能 返回 arr 中最后一个 == num 的数字的索引 **/ func BinarySearchLastV2(arr []int64, num int64) int { var ( low = 0 n = len(arr) high = n - 1 ) /** 1. for 循环结束后, low &amp;gt; high 2.</description>
    </item>
    <item>
      <title>算法中使用哨兵变量(TODO)</title>
      <link>https://bwangel.me/docs/algo/algo-sentry/</link>
      <pubDate>Sun, 11 Sep 2022 10:52:23 +0800</pubDate>
      <guid>https://bwangel.me/docs/algo/algo-sentry/</guid>
      <description>背景 哨兵，现实中是用于解决国家之间的边界问题。&#xA;在算法程序中，我们设置一些冗余的变量，让算法程序处理边界问题时更加容易，这些变量就被称为哨兵。&#xA;本文将会举例说明，哨兵变量在算法程序中的应用。&#xA;插入排序 插入排序是一种常用的排序算法，它的思路是&#xA;用 i 从 1 开始遍历数组中每个元素 从后往前遍历 1-i 的每个元素，找到第一个比当前元素小的元素，将其插入到该元素之后 Note: 先挪位置，循环结束后再在 j 指示的索引中(第一个比当前元素小的元素)插入当前值 func InsertSort[T ttypes.Number](arr []T) []T { res := make([]T, len(arr)) copy(res, arr) for i := 1; i &amp;lt; len(res); i++ { j := i current := res[i] for j &amp;gt; 0 &amp;amp;&amp;amp; res[j-1] &amp;gt; current { res[j] = res[j-1] j-- } res[j] = current } return res } 演示图:&#xA;哨兵模式 哨兵模式的代码如下，它在数组的前面添加一个元素。&#xA;每次开始遍历前，它将当前需要插入的元素放到数组头部(res[0])。这样就算 1-i 中没有比 res[i] 小的元素，但循环到最后还是会触发条件 not (res[0] &amp;gt; current), 达到跳出循环的目的。</description>
    </item>
    <item>
      <title>哈希表学习笔记</title>
      <link>https://bwangel.me/docs/algo/hash/</link>
      <pubDate>Wed, 29 Aug 2018 23:34:29 +0800</pubDate>
      <guid>https://bwangel.me/docs/algo/hash/</guid>
      <description></description>
    </item>
    <item>
      <title>变态跳台阶问题的解题思路</title>
      <link>https://bwangel.me/docs/algo/jump-stairs/</link>
      <pubDate>Sun, 08 Jul 2018 14:46:42 +0800</pubDate>
      <guid>https://bwangel.me/docs/algo/jump-stairs/</guid>
      <description>&lt;p&gt;简介：本文主要记录了 变态跳台阶问题 的推导过程&lt;/p&gt;</description>
    </item>
    <item>
      <title>完全二叉树与满二叉树</title>
      <link>https://bwangel.me/docs/algo/binary-tree/</link>
      <pubDate>Sat, 31 Mar 2018 22:42:53 +0800</pubDate>
      <guid>https://bwangel.me/docs/algo/binary-tree/</guid>
      <description>&lt;p&gt;本文主要讲述了完全二叉树和满二叉树的定义及一些特性&lt;/p&gt;</description>
    </item>
    <item>
      <title>Go与数据结构之二叉搜索树</title>
      <link>https://bwangel.me/docs/algo/go-binarysearchtree/</link>
      <pubDate>Thu, 01 Mar 2018 22:22:52 +0800</pubDate>
      <guid>https://bwangel.me/docs/algo/go-binarysearchtree/</guid>
      <description>&lt;p&gt;&lt;strong&gt;简介&lt;/strong&gt;: 利用Go语言实现二叉搜索树并为其编写单元测试&lt;/p&gt;</description>
    </item>
    <item>
      <title>算法复杂度小记</title>
      <link>https://bwangel.me/docs/algo/algorithm-complexity/</link>
      <pubDate>Fri, 08 Sep 2017 00:24:12 +0800</pubDate>
      <guid>https://bwangel.me/docs/algo/algorithm-complexity/</guid>
      <description>&lt;p&gt;本文主要书写了本人对于算法复杂度的一些理解，并辅以一些例子进行说明&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
